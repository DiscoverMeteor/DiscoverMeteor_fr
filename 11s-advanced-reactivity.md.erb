---
title: Réactivité Avancée
slug: advanced-reactivity
date: 0011/01/02
number: 11.5
points: 10
sidebar: true
photoUrl: http://www.flickr.com/photos/ikewinski/8676146109/
photoAuthor: Mike Lewinski
contents: Apprendre comment créer des sources de données réactives dans Meteor.|Créer un exemple simple de source de donnée réactive.|Voir comment Deps se démarque d'AngularJS.
paragraphs: 29
---

Il est rare d'avoir à écrire soi-même le code de suivi des dépendances, mais il est sans aucun doute utile d'en saisir le sens pour comprendre comment le flux de résolution des dépendances fonctionne.

Imaginez que l'on veuille suivre combien des amis Facebook de l'utilisateur ont "aimé" chaque article dans Microscope. Supposons que l'on ai déjà mis en place l'authentification de l'utilisateur avec Facebook, fait les appels API appropriés et analysé les données pertinentes. Nous avons donc une fonction asynchrone côté client qui retourne le nombre de "j'aime" `getFacebookLikeCount(user, url, callback)`.

La chose importante à ne pas oublier à propos d'une telle fonction est qu'elle est non-réactive et qu'elle ne s'effectue pas en temps réel. Elle réalisera une requête HTTP vers Facebook, extraira des données et les rendra disponibles à l'application dans le rappel asynchrone, mais la fonction ne se réexecutera pas d'elle-même quand le total changera sur Facebook et notre interface ne changera pas quand les données sous-jacentes changent.

Pour remédier à cela, l'on peut commencer par utiliser `setInterval` pour appeller notre fonction toutes les quelques seconds:

~~~js
currentLikeCount = 0;
Meteor.setInterval(function() {
  var postId;
  if (Meteor.user() && postId = Session.get('currentPostId')) {
    getFacebookLikeCount(Meteor.user(), Posts.find(postId), 
      function(err, count) {
        if (!err)
          currentLikeCount = count;
      });
  }
}, 5 * 1000);
~~~

Chaque fois que l'on contrôle la variable `currentLikeCount`, l'on peut s'attendre à avoir le nombre correct avec une marge d'erreur de cinq secondes. On peut désormais utiliser cette variable en tant qu'utilitaire comme ceci: 

~~~js
Template.postItem.likeCount = function() {
  return currentLikeCount;
}
~~~

Néanmoins, rien n'indique pour l'instant à notre template d'être rafraîchit quand `currentLikeCount` change. Bien que la variable soit maintenant en pseudo temps-réel du fait qu'elle change toute seule, elle n'est pas *réactive* donc elle ne peut toujours pas communiquer correctement avec le reste de l'écosystème Meteor.

### Suivi de la Réactivité: Calculs

La réactivité de Meteor est gérée par des *dépendences*, des structures de donnée qui observent un ensemble de calculs. 

Comme nous l'avons vu précédemment dans l'aparté sur la réactivité, un calcul est un morceau de code qui utilise des données réactives. Dans notre cas, un calcul a été créé implicitement pour le modèle `postItem`. Chaque utilitaire dans le gestionnaire de ce modèle fonctionne dans le cadre de ce calcul.

On peut voir ce calcul comme la partie du code qui est "en charge" des données réactives. Lorsque les données changent, ce sera ce calcul qui en sera informé (via `invalidate()`), et c'est ce calcul qui décide si quelque chose doit être fait.

### Transformer une Variable en une Fonction Réactive

Pour transformer notre variable `currentLikeCount` en une source de donnée réactive, nous devons suivre tous les calculs qui l'utilisent dans une dépendance. Cela requiert de la changer d'une variable en une fonction (qui retournera une valeur):

~~~js
var _currentLikeCount = 0;
var _currentLikeCountListeners = new Deps.Dependency();

currentLikeCount = function() {
  _currentLikeCountListeners.depend();
  return _currentLikeCount;
}

Meteor.setInterval(function() {
  var postId;
  if (Meteor.user() && postId = Session.get('currentPostId')) {
    getFacebookLikeCount(Meteor.user(), Posts.find(postId), 
      function(err, count) {
        if (!err && count !== _currentLikeCount) {
          _currentLikeCount = count;
          _currentLikeCountListeners.changed();
        }
      });
  }
}, 5 * 1000);
~~~
<%= highlight "1~7,14~17" %>

Nous avons ici mis en place une dépendance `_currentLikeCountListeners`, qui suit tous les calculs dans lesquels `currentLikeCount()` a été utilisé. Quand la valeur de `_currentLikeCount` change, nous appellons la fonction `changed()` sur cette dépendance, qui invalide tous les calculs que nous suivions.

These computations can then go ahead and deal with the change on a case-by-case basis. 

### Comparing Deps to Angular

[Angular](http://angularjs.org/) is a client-side only reactive rendering library, developed by the good folks at Google. It's illustrative to compare Meteor's approach to dependency tracking to Angular's, as the approaches are quite different.

We've seen that Meteor's model uses blocks of code called computations. These computations are tracked by special "reactive" data sources (functions) that take care of invalidating them when appropriate. So the data source _explicitly_ informs all of it's dependencies when they need to call `invalidate()`. Note that although this is generally when data has changed, the data source could potentially also decide to trigger invalidation for other reasons.

Additionally, although computations usually just re-run when invalidated, you can set them up to behave any way you want. All this gives us a high level of control over reactivity.

In Angular, reactivity is mediated by the `scope` object. A scope can be thought of as plain JavaScript object with a couple of special methods. 

When you want to reactively depend on a value in a scope, you call `scope.$watch`, providing the expression that you are interested in (i.e. which parts of the scope you care about) and a listener function that will run every time that expression changes. So you explicitly state exactly what you want to do every time the value of the expression changes.

Going back to our Facebook example, we would write:

~~~js
$rootScope.$watch('currentLikeCount', function(likeCount) {
  console.log('Current like count is ' + likeCount);
});
~~~

Of course, just like you rarely set up computations in Meteor, you don't often call `$watch` explicitly in Angular as `ng-model` directives and `{{expressions}}` automatically set up watches that then take care of re-rendering on change.

When such a reactive value has changed, `scope.$apply()` must then be called. This re-evaluates every watcher of the scope, but only calls the listener function of watchers whose expression's value has *changed*. 

So `scope.$apply()` is similar to `dependency.changed()`, except that it acts at the level of the scope, rather than giving you the control to say precisely which listeners should be re-evaluated. That being said, this slight lack of control gives Angular the ability to be very smart and efficient in the way it determines precisely which listeners need to be re-evaluated.

With Angular, our `getFacebookLikeCount()` function code would've looked something like this:

~~~js
Meteor.setInterval(function() {
  getFacebookLikeCount(Meteor.user(), Posts.find(postId), 
    function(err, count) {
      if (!err) {
        $rootScope.currentLikeCount = count;
        $rootScope.$apply();
      }
    });
}, 5 * 1000);
~~~
<%= highlight "5~6" %>

Admittedly, Meteor takes care of most of the heavy lifting for us and lets us benefit from reactivity without much work on our part. But hopefully, learning about these patterns will prove helpful if you ever need to push things further. 